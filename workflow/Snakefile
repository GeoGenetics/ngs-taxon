import numpy as np
import pandas as pd

snakemake.utils.min_version("9.0.0")

# Define wrapper versions
wrapper_ver = "v7.0.0"

# Default value for testing purposes
units = config.get(
    "units",
    pd.read_table(
        "config/units.tsv",
        converters={"seq_type": (lambda x: x.casefold())},
        comment="#",
    )
    .set_index(["sample", "library", "lane"], drop=False)
    .assign(
        read_type_raw=lambda x: [["R1", "R2"]] * 4,
        read_type_trim=lambda x: [
            ["R1", "R2", "singleton", "collapsed", "collapsedtrunc"]
        ]
        * 4,
    ),
)
snakemake.utils.validate(
    units.drop(columns=["read_type_raw", "read_type_trim"]),
    schema=Path(workflow.current_basedir) / "schemas/units.schema.yaml",
)
# Default value for testing purposes
config = config.get("cfg", config)
snakemake.utils.validate(
    config, schema=Path(workflow.current_basedir) / "schemas/config.schema.yaml"
)


include: "rules/utils.smk"
include: "rules/map.smk"
include: "rules/merge_alns.smk"
include: "rules/bam_filter.smk"
include: "rules/metadmg.smk"


###########################
### Taxonomy assignment ###
###########################


rule multiqc:
    input:
        ### Map
        expand_pd(
            expand_pandas(
                "logs/shards/{tool}/{sample}_{library}_{read_type_map}.{ref}.{n_shard}-of-{tot_shards}.log",
                ref_sets,
                allow_missing=True,
            ),
            units,
        ),
        ### Samtools Stats
        expand(
            expand(
                rules.align_stats.output.txt,
                zip,
                **ref_sets.to_dict("list"),
                allow_missing=True,
            ),
            zip,
            **units.to_dict("list"),
        ),
        ### metaDMG dfit
        expand(
            rules.metadmg_dfit.output.dfit,
            zip,
            **units.assign(read_type_map="collapsed").to_dict("list"),
        ),
        ### metaDMG LCA Aggregated Stats
        expand(
            rules.metadmg_aggregate.output.stats,
            zip,
            **units.assign(read_type_map="collapsed").to_dict("list"),
        ),
    output:
        html="reports/multiqc.html",
        data="reports/multiqc_data.zip",
    log:
        "logs/reports/multiqc.log",
    benchmark:
        "benchmarks/reports/multiqc.log"
    params:
        extra="--force --clean-up " + config.get("report", {}).get("multiqc", ""),
    localrule: True
    threads: 1
    resources:
        mem=lambda w, attempt: f"{10* attempt} GiB",
        runtime=lambda w, attempt: f"{30* attempt} m",
    wrapper:
        f"{wrapper_ver}/bio/multiqc"


rule all:
    input:
        qc=rules.multiqc.output.html,
        res=[
            expand(
                rules.shard_saturated_reads_extract.output.fq,
                zip,
                **units.assign(read_type_map="collapsed").to_dict("list"),
            ),
            expand(
                rules.metadmg_aggregate.output.stats,
                zip,
                **units.assign(read_type_map="collapsed").to_dict("list"),
            ),
            expand(
                rules.metadmg_damage.output.stats,
                zip,
                **units.assign(read_type_map="collapsed").to_dict("list"),
            ),
            (
                expand(
                    rules.align_lca.output.stats,
                    zip,
                    **units.assign(read_type_map="collapsed").to_dict("list"),
                )
                if is_activated("bam_filter/lca")
                else []
            ),
        ],
    message:
        "Read mapping finished successfully!"
    default_target: True
